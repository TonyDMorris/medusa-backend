package castle

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/algolia/algoliasearch-client-go/v3/algolia/opt"
	"github.com/algolia/algoliasearch-client-go/v3/algolia/search"
)

type AutoGenerated struct {
	Results []Results `json:"results"`
}
type Artboxes struct {
	Title    string `json:"title"`
	StatusID int    `json:"status_id"`
}
type Sku struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type Title struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type ArtistTitle struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type Heading struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type Bodytext struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type MetaDescription struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type MetaKeywords struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type Mediums struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type Subjects struct {
	Value        string        `json:"value"`
	MatchLevel   string        `json:"matchLevel"`
	MatchedWords []interface{} `json:"matchedWords"`
}
type HighlightResult struct {
	Sku             Sku             `json:"sku"`
	Title           Title           `json:"title"`
	ArtistTitle     ArtistTitle     `json:"artist_title"`
	Heading         Heading         `json:"heading"`
	Bodytext        Bodytext        `json:"bodytext"`
	MetaDescription MetaDescription `json:"meta_description"`
	MetaKeywords    MetaKeywords    `json:"meta_keywords"`
	Mediums         []Mediums       `json:"mediums"`
	Subjects        []Subjects      `json:"subjects"`
}
type Hits struct {
	Sku                       string          `json:"sku"`
	Title                     string          `json:"title"`
	ArtistTitle               string          `json:"artist_title"`
	ArtistTitleFilterGroup    string          `json:"artist_title_filter_group"`
	Price                     float64         `json:"price"`
	PriceFilter               float64         `json:"price_filter"`
	PriceWithoutVat           float64         `json:"price_without_vat"`
	DiscountedPrice           float64         `json:"discounted_price"`
	DiscountedPriceWithoutVat float64         `json:"discounted_price_without_vat"`
	DiscountPercentages       []interface{}   `json:"discount_percentages"`
	PreviouslyDiscounted      bool            `json:"previously_discounted"`
	PriceOnApplication        bool            `json:"price_on_application"`
	StatusID                  int             `json:"status_id"`
	OriginalsStatusID         int             `json:"originals_status_id"`
	IsEmbargoed               bool            `json:"is_embargoed"`
	Thumbnail                 string          `json:"thumbnail"`
	SquareThumbnail           string          `json:"square_thumbnail"`
	HoverThumbnail            string          `json:"hover_thumbnail"`
	URL                       string          `json:"url"`
	Heading                   string          `json:"heading"`
	Bodytext                  string          `json:"bodytext"`
	Stock                     bool            `json:"stock"`
	AvailableToBuy            bool            `json:"available_to_buy"`
	MetaTitle                 string          `json:"meta_title"`
	MetaDescription           string          `json:"meta_description"`
	MetaKeywords              string          `json:"meta_keywords"`
	Mediums                   []string        `json:"mediums"`
	Type                      string          `json:"type"`
	Width                     float64         `json:"width"`
	Height                    float64         `json:"height"`
	ReleaseDate               string          `json:"release_date"`
	ReleaseDateTimestamp      int             `json:"release_date_timestamp"`
	AvailabilityDateTimestamp int             `json:"availability_date_timestamp"`
	Subjects                  []string        `json:"subjects"`
	Artboxes                  []Artboxes      `json:"artboxes"`
	Collections               []interface{}   `json:"collections"`
	CollectionsFilterGroup    []interface{}   `json:"collections_filter_group"`
	Statuses                  []string        `json:"statuses"`
	ObjectID                  string          `json:"objectID"`
	HighlightResult           HighlightResult `json:"_highlightResult"`
}
type Exhaustive struct {
	NbHits bool `json:"nbHits"`
	Typo   bool `json:"typo"`
}
type RenderingContent struct {
}
type Format struct {
	Total int `json:"total"`
}
type AfterFetch struct {
	Format Format `json:"format"`
	Total  int    `json:"total"`
}
type ProcessingTimingsMS struct {
	AfterFetch AfterFetch `json:"afterFetch"`
	Total      int        `json:"total"`
}
type Results struct {
	Hits                []Hits              `json:"hits"`
	NbHits              int                 `json:"nbHits"`
	Page                int                 `json:"page"`
	NbPages             int                 `json:"nbPages"`
	HitsPerPage         int                 `json:"hitsPerPage"`
	ExhaustiveNbHits    bool                `json:"exhaustiveNbHits"`
	ExhaustiveTypo      bool                `json:"exhaustiveTypo"`
	Exhaustive          Exhaustive          `json:"exhaustive"`
	Query               string              `json:"query"`
	Params              string              `json:"params"`
	Index               string              `json:"index"`
	RenderingContent    RenderingContent    `json:"renderingContent"`
	ProcessingTimeMS    int                 `json:"processingTimeMS"`
	ProcessingTimingsMS ProcessingTimingsMS `json:"processingTimingsMS"`
}

func ArtistTest() {
	client := search.NewClient("NLWUYZGF0K", "63afed7d2f190c666b5ca3fe4c6d9845")
	index := client.InitIndex("artists")

	bytes, err := os.ReadFile("./artists.txt")
	if err != nil {
		panic(err)
	}
	artists := strings.Split(string(bytes), "\n")

	for _, artist := range artists {
		params := []interface{}{
			opt.HitsPerPage(1000),
		}
		res, err := index.Search(artist, params...)
		if err != nil {
			fmt.Println(err.Error())
			panic(err)
		}

		if len(res.Hits) > 0 {

			hit := res.Hits[0]
			bio := make(map[string]interface{})
			for key, val := range hit {
				if key != "_highlightResult" {
					bio[key] = val
				}
			}
			bytes, err := json.Marshal(bio)
			if err != nil {
				panic(err)
			}
			err = os.WriteFile(fmt.Sprintf("./scraped/artists/%s/profile/bio.json", artist), bytes, 0644)
			if err != nil {
				panic(err)
			}
		}

	}
}
func Test() {
	client := search.NewClient("NLWUYZGF0K", "63afed7d2f190c666b5ca3fe4c6d9845")
	index := client.InitIndex("artists")

	// res, err := client.ListAPIKeys()
	// if err != nil {
	// 	panic(err)
	// }
	// bytes, _ := json.Marshal(res)
	// err = os.WriteFile("result.json", bytes, 0644)
	// if err != nil {
	// 	panic(err)
	// }

	// res, err := client.GetAPIKey("ZjQwNGZhYzllODkxMjg1YTM1NjYwMjA3MjYxMDA4ZDA4YzAxYzExYjJiYjhmZDcxNDc0YzIzMTE4MDY0MjEwMWZpbHRlcnM9YXJ0aXN0X3RpdGxlJTNBJTIyQWxleCtFY2hvJTIy")
	// if err != nil {
	// 	panic(err)
	// }
	// Search the index and print the results
	bytes, err := os.ReadFile("./artists.txt")
	if err != nil {
		panic(err)
	}
	artists := strings.Split(string(bytes), "\n")
	artistsMap := make(map[string][]Hits)
	for _, artist := range artists {
		params := []interface{}{
			opt.HitsPerPage(1000),
		}
		res, err := index.Search(artist, params...)
		if err != nil {
			fmt.Println(err.Error())
			panic(err)
		}

		bytes, _ := json.Marshal(res)
		newRes := Results{}
		err = json.Unmarshal(bytes, &newRes)
		if err != nil {
			panic(err)
		}

		for _, hit := range newRes.Hits {
			_, ok := artistsMap[hit.ArtistTitle]
			if !ok {
				artistsMap[hit.ArtistTitle] = []Hits{hit}
				continue
			}
			artistsMap[hit.ArtistTitle] = append(artistsMap[hit.ArtistTitle], hit)

		}

	}

	for artist, hits := range artistsMap {
		artistSlug := strings.Replace(strings.TrimSpace(strings.ToLower(artist)), " ", "-", -1)
		if !in(artists, artistSlug) {
			continue
		}
		for _, hit := range hits {
			bytes, err := json.Marshal(hit)
			if err != nil {
				panic(err)
			}
			sanitisedSKU := strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(strings.TrimSpace(hit.Sku), "|", ""), " ", "_"), "/", "")
			err = os.WriteFile(fmt.Sprintf("./scraped/artists/%s/pieces/%s.json", artistSlug, sanitisedSKU), bytes, 0644)
			if err != nil {
				if err == os.ErrNotExist {
					continue
				} else {
					panic(err)
				}
			}
		}
	}

}

func in(o []string, new string) bool {
	for _, item := range o {
		if item == new {
			return true
		}
	}
	return false
}
